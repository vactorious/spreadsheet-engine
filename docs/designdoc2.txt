CS130 Project 2 - Design Document
=================================

Please answer all questions in this design document.  Note that the final
feedback section is optional, and you are not required to answer it if you
don't want to.

Unanswered or incompletely answered questions, or answers that don't actually
match the code/repository, will result in deductions.

Answers don't have to be deeply detailed!  We are mainly looking for an
overview or summary description of how your project works, and your team's
experiences working on this project.

Logistics (7 pts)
-----------------

L1.  [2pts] Enumerate all teammates here.
          Matthew Gonzalgo
          Victor Huang
          John Kim

L2.  [2pts] What did each teammate focus on during this project?
          Matthew: JSON loading/saving, moving/copying sheets, general testing,
                   performance analysis
          Victor:  Fixing previous project test failures, renaming sheets, cell
                   update notifications, performance analysis
          John:    Fixing previous project test failures, renaming sheets, cell
                   update notifications, performance analysis, feature testing

L3.  [3pts] Approximately how many hours did each teammate spend on the project?
          Matthew: 25 hours
          Victor:  25 hours
          John:    25 hours


Spreadsheet Engine Design (16 pts)
----------------------------------

D1.  [4pts] Briefly describe how your workbook-loading code operates.  Does
     it do anything sophisticated to optimize the performance of loading a
     workbook, such as deferring cell-value update calculations, or analyzing
     the graph of cell dependencies?
          Our load_workbook() function loads an opened JSON file and creates a
          new Workbook object. It then goes through the "sheets" list of
          dictionaries, calling new_sheet() using the value from "name" and
          set_cell_contents() for each loc-contents pair from "cell-contents".
          Within load_workbook(), the call to set_cell_contents() handles all
          of the necessary updates and calculations.

D2.  [4pts] Sheet-level operations like copying a sheet, deleting a sheet,
     renaming a sheet, or even creating a new sheet, can cause cell values
     to be updated.  How does your workbook identify such cells and ensure
     that they are updated properly?
          All cell-to-cell updates are done in set_cell_contents(), where
          the parents (cells that it references) and children (cells that
          reference it) of each cell are used. The Sheets class stores
          the cell instances as an attribute, and so sheet-level operations
          simply iterate through the cells in that sheet and update them one by
          one.

D3.  [8pts] When renaming a sheet, cells with formulas that explicitly
     reference the renamed sheet must be updated with the new sheet name.
     Give an overview of how your implementation updates these formulas.
          When a sheet is renamed, a visitor is run through every cell's parse
          tree in that sheet. This visitor replaces every reference to the old
          name with the new name. Then, a reconstructor is run on the parse tree
          to get a new formula with the new sheet name, and the cell's contents
          are updated. The only other cells that explicitly reference the renamed
          sheet are the direct children of cells in said sheet. Therefore, we
          iterate through those direct children and do the same thing (run a
          visitor, reconstructor).

Spreadsheet Engine Code Review (24 pts)
---------------------------------------

R1.  [4pts] What part of your spreadsheet code-base did your team select to
     review?  Why did you select this portion of your code to review?
          Our team reviewed the code that parses and evaluates formulas, including
          the parser, visitor, and transformer implementations. We selected this
          portion of the code to review because most of it was implemented by one
          group member, and the rest of the group was not as familiar with it.
          Also, knowing how the formulas were evaluated/parsed is very useful
          when debugging and implementing other features, so it is important for
          everyone to know.

R2.  [4pts] Approximately how much code did your team review?  How much time did
     the meeting take?
          We reviewed ~300 lines of code. The meeting took approx. 1 hour.

R3.  [8pts] Include the list of action-items that were generated by the
     code-review here.
          - Instead of using lists for iterating, switch to using generators
            for the sake of time/memory efficiency.
          - A stretch goal would be to use an interpreter instead of a
            transformer, because it allows for more flexibility for the more
            advanced features that we will implement in future projects.

R4.  [4pts] Have you been able to address the action items identified?  If not,
     what is your plan and timeframe to do so?
          We have not been able to address the action items identified.
          We plan to work on it over the next projects to improve efficiency,
          and for the case of switching to the interpreter, before we implement
          more advanced features that require it. The other action item has
          a more flexible time frame, so we are hoping to accomplish it next
          project, when we improve performance.

R5.  [4pts] Reflect on whether the code review helped with knowledge-sharing in
     the team.  Do teammates feel more confident maintaining the code that was
     reviewed, and/or extending the code in the future?
          After having done the code review, we feel like we understand the code
          base much better, including the parts we did not focus on. As such,
          team members feel more confident in implementing new features that
          rely on the reviewed code, as well as maintaining the code.

Performance Analysis (22 pts)
-----------------------------

In this project you must measure and analyze the performance of two central
areas of your spreadsheet engine.  Using pair programming, construct some
performance tests to exercise these aspects of your engine, and use a profiler
to identify where your program is spending the bulk of its time.

A1.  [4pts] Briefly enumerate the performance tests you created to exercise
     your implementation, along with the teammates that collaborated to
     implement each of them.
          All teammates collaborated to implement the performance tests.
          The tests are as follows:
          - Update propagation through one long chain of cells
          - Update propagation through many shallow chains of cells
          - Cycle detection of one large cycle
          - Cycle detection of many small cycles
          - Cycle detection of one cell with many cycles

A2.  [4pts] What profiler did you choose to run your performance tests with?
     Why?  Give an example of how to invoke one of your tests with the profiler.
          We chose to use cProfile because it is a built-in python module that
          can provide all of the profiling functionality that we need. We
          created a command in the makefile to start all performance tests:
          make test-performance. The stress testing class has a setUp()
          function which starts up the profiler. It also has a tearDown()
          function which prepares results for printing (sorting, cleaning). A
          list of function calls and timings are produced for each performance
          test.

A3.  [8pts] What are ~3 of the most significant hot-spots you identified in your
     performance testing?  Did you expect these hot-spots, or were they
     surprising to you?
          1. Our get_extent() function was the most severe hot-spot in our code.
             It took more than two-thirds of the total runtime of the tests. This
             was expected, because the function adds cell locations to a set and
             takes the max every time a cell is updated, which is extremely
             inefficient.
          2. Our parse_cell_contents() function was another hot-spot in our code.
             This was due to Lark's parse() function taking up a bulk of the time.
             This was kind of unexpected, but understandable because each formula
             needed to be parsed. While initial parsing of formulas took a long
             time, updating cells later took comparatively little time.
          3. Our quantify_cell_loc() function was another hot-spot in our code,
             but pales in comparison to the first two. This is kind of expected
             because it needs to be called every time a cell is updated (to get
             the row/col numbers from a location string). It is hard to decide the
             best way to make this function more efficient.
           

A4.  [6pts] Reflect on the experience of pair-programming as you constructed
     these tests.  What went well with it?  What would you like to try to do
     better in the future?
          Since our group does pair-programming regularly, it was not much
          different than our normal workflow. It was easy to coordinate tasks
          while working on the same file. We could give and receive immediate
          feedback while coding, and that creates better coding efficiency. In
          the future, we could try to communicate more and explain what we are
          doing while coding.

Section F:  CS130 Project 3 Feedback [OPTIONAL]
-----------------------------------------------

These questions are OPTIONAL, and you do not need to answer them.  Your grade
will not be affected by answering or not answering them.  Also, your grade will
not be affected by negative feedback - we want to know what went poorly so that
we can improve future versions of the course.

F1.  What parts of the assignment did you find highly enjoyable?  Conversely,
     what parts of the assignment did you find unenjoyable?


F2.  What parts of the assignment helped you learn more about software
     engineering best-practices, or other useful development skills?
     What parts were not helpful in learning these skills?


F3.  Were there any parts of the assignment that seemed _unnecessarily_ tedious?
     (Some parts of software development are always tedious, of course.)


F4.  Do you have any feedback and/or constructive criticism about how this
     project can be made better in future iterations of CS130?
